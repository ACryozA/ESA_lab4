# Лабораторная работа №4 по курсу "Архитектура корпоративных систем"
**Выполнили:** студенты группы 6131-010402D _Маслюк Александр_:dizzy_face: и _Юдина Алёна_:wink:.

## Java Message Service

### Общая задача

Нужно добавить новую функциональность в ранее созданное приложение, а именно: механизм журналирования и watchdog для отслеживания определенных изменений. Журналирование должно обеспечивать простой механизм записи информации об изменениях в системе в специальную таблицу базы данных. Watchdog должен отправлять уведомления по электронной почте о конкретных изменениях в системе на указанные адреса электронной почты.

### Задание 1

Была добавлена таблица `log_entity` в базу данных, каждая строка которой описывает изменение информации в других таблицах. Строка содержит тип события (`CREATE`, `UPDATE`, `DELETE`), тип сущности, идентификатор сущности, текстовое описание изменения, подробные данные в виде строки (например, JSON) и временную метку события. Для работы с этой таблицей используется сущность `LogEntity`, отображающая все перечисленные поля и служащая основой для журналирования изменений в системе.

### Задание 2

На сервере приложений GlassFish настроены административные объекты JMS, в том числе очередь, используемая для передачи лог‑событий. В качестве брокера сообщений используется контейнер в Docker, к которому приложение подключается через настроенный `ConnectionFactory`. Приложение работает с очередью через бин `Queue` и `JmsTemplate`, что позволяет прозрачно отправлять сообщения о любых изменениях сущностей во внешний JMS‑брокер.

### Задание 3

Приложение модифицировано так, что при каждом изменении JPA‑сущностей (создание, обновление, удаление) в брокер сообщений отправляется объект события. Для этого используется JPA‑слушатель, который реагирует на `@PostPersist`, `@PostUpdate` и `@PostRemove`, формирует объект `EntityChangeEvent` с типом события, информацией о сущности, её идентификатором и данными, после чего передаёт его в очередь через сервис JMS.

### Задание 4

Разработан компонент для приёма сообщений из очереди, реализованный как `@JmsListener`. Этот компонент проверяет тип и структуру полученного `EntityChangeEvent`, на его основе создаёт экземпляр `LogEntity` и сохраняет запись в таблицу `log_entity` с помощью репозитория `LogEntityRepository`, тем самым реализуя централизованное журналирование всех изменений.

### Задание 5

В качестве событий для почтовых уведомлений выбрано удаление сущностей. Для каждого полученного события компонент обработки проверяет тип операции, и только если это удаление (`DELETE`), событие считается подходящим для отправки уведомления и дополнительно обрабатывается почтовым сервисом.

### Задание 6

Разработан почтовый сервис, который получает информацию о событии удаления и отправляет email‑уведомление с описанием изменения. Компонент‑слушатель JMS при получении события удаления формирует текст уведомления на основе данных `EntityChangeEvent` и вызывает сервис отправки почты, использующий настроенный SMTP‑сервер приложения.

### Задание 7

Все описанные компоненты интегрированы в единый контур: изменение сущности вызывает отправку события в JMS, затем сообщение принимается, валидируется и записывается в таблицу `log_entity`, а при удалении сущности дополнительно отправляется email‑уведомление. 
Результат работы представлен на скриншотах ниже!

<img width="602" height="242" alt="image" src="https://github.com/user-attachments/assets/a28a5bc6-eb0c-41cf-a675-627d93a3d73d" />

